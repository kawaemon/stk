//! Virtual machine for LCD controller HD44780
//! datasheet: <https://cdn-shop.adafruit.com/datasheets/HD44780.pdf>

use std::fmt::Debug;

// generated by src/cgrom.py
#[rustfmt::skip]
const CGROM: &[char; 256] = &[
    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
    ' ', '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?',
    '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '¥', ']', '^', ' ',
    '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '(', '|', ')', '→', '←',
    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
    ' ', '｡', '｢', '｣', '`', '･', 'ｦ', 'ｧ', 'ｨ', 'ｩ', 'ｪ', 'ｫ', 'ｬ', 'ｭ', 'ｮ', 'ｯ',
    'ｰ', 'ｱ', 'ｲ', 'ｳ', 'ｴ', 'ｵ', 'ｶ', 'ｷ', 'ｸ', 'ｹ', 'ｺ', 'ｻ', 'ｼ', 'ｽ', 'ｾ', 'ｿ',
    'ﾀ', 'ﾁ', 'ﾂ', 'ﾃ', 'ﾄ', 'ﾅ', 'ﾆ', 'ﾇ', 'ﾈ', 'ﾉ', 'ﾊ', 'ﾋ', 'ﾌ', 'ﾍ', 'ﾎ', 'ﾏ',
    'ﾐ', 'ﾑ', 'ﾒ', 'ﾓ', 'ﾔ', 'ﾕ', 'ﾖ', 'ﾗ', 'ﾘ', 'ﾙ', 'ﾚ', 'ﾛ', 'ﾜ', 'ﾝ', 'ﾞ', 'ﾟ',
    'α', 'ä', 'β', 'ε', 'μ', 'ε', 'ρ', 'g', '√', '┘', 'j', 'x', '€', 'L', 'ü', 'ö',
    'p', 'q', 'θ', '∞', 'Ω', 'ü', 'Σ', 'π', 'x', '̄', 'y', '千', '万', '円', '÷', '█',
];

#[derive(Debug)]
pub struct Hd44780 {
    /// instruction register
    ir: u8,

    #[allow(dead_code)]
    /// data register
    dr: u8,

    /// address counter for ddram
    ac_ddram: u8,
    /// address counter for cgram
    ac_cgram: u8,

    /// display content
    ddram: [u8; 80],

    config: Config,
    bus_state: BusState,
}

// FIXME: move this to interface crate
pub trait PinObserver {
    type PinState;
    fn update(&mut self, pin: Self::PinState);
}

pub struct Hd44780PinState {
    pub rs: Option<bool>,
    pub rw: Option<bool>,
    pub e: Option<bool>,
    pub db7: Option<bool>,
    pub db6: Option<bool>,
    pub db5: Option<bool>,
    pub db4: Option<bool>,
    pub db3: Option<bool>,
    pub db2: Option<bool>,
    pub db1: Option<bool>,
    pub db0: Option<bool>,
}

struct Hd44780Signal {
    rs: bool,
    rw: bool,
    e: bool,
    db: u8,
}

#[derive(Debug)]
struct Config {
    #[doc(alias = "DL")]
    _8bit_mode: bool,

    #[doc(alias = "N")]
    _2lines_display: bool,

    #[doc(alias = "F")]
    font_5x10: bool,

    #[doc(alias = "D")]
    display_on: bool,

    #[doc(alias = "C")]
    cursor_shown: bool,

    #[doc(alias = "B")]
    cursor_blink: bool,

    #[doc(alias = "I/D")]
    increment: bool,

    #[doc(alias = "S")]
    shift: bool,

    #[doc(alias = "S/C")]
    cursor_follows_shift: bool,

    #[doc(alias = "R/L")]
    shift_to_right: bool,
}

impl Config {
    fn new() -> Self {
        // refer to datasheet p23: internal reset circuit
        Self {
            _8bit_mode: true,
            _2lines_display: false,
            font_5x10: false,
            display_on: false,
            cursor_shown: false,
            cursor_blink: false,
            increment: true,
            shift: false,

            // these below are not listed on p23
            cursor_follows_shift: false,
            shift_to_right: false,
        }
    }
}

impl From<Hd44780PinState> for Hd44780Signal {
    fn from(x: Hd44780PinState) -> Self {
        // some pins are pulled up.
        // refer to datasheet P54.
        Self {
            rs: x.rs.unwrap_or(true),
            rw: x.rw.unwrap_or(true),
            e: x.e.unwrap_or(false), // no pulls. defaulting to low.
            db: (if x.db7.unwrap_or(true) { 1u8 << 7 } else { 0 }
                | if x.db6.unwrap_or(true) { 1u8 << 6 } else { 0 }
                | if x.db5.unwrap_or(true) { 1u8 << 5 } else { 0 }
                | if x.db4.unwrap_or(true) { 1u8 << 4 } else { 0 }
                | if x.db3.unwrap_or(true) { 1u8 << 3 } else { 0 }
                | if x.db2.unwrap_or(true) { 1u8 << 2 } else { 0 }
                | if x.db1.unwrap_or(true) { 1u8 << 1 } else { 0 }
                | if x.db0.unwrap_or(true) { 1u8 << 0 } else { 0 }),
        }
    }
}

impl PinObserver for Hd44780 {
    type PinState = Hd44780PinState;

    fn update(&mut self, pin: Self::PinState) {
        let signal: Hd44780Signal = pin.into();

        let should_trigger = match (self.bus_state.prev_e, signal.e) {
            // falling edge
            (true, false) => true,
            // rising edge
            (false, true) => false,
            // no state changes
            (true, true) | (false, false) => false,
        };
        self.bus_state.prev_e = signal.e;

        if !should_trigger {
            return;
        }

        if !self.config._8bit_mode {
            if !self.bus_state.received_4bit_half {
                self.ir = signal.db & 0b1111_0000;
                self.bus_state.received_4bit_half = true;
                return;
            }

            self.bus_state.received_4bit_half = false;
            self.ir |= (signal.db & 0b1111_0000) >> 4;
        } else {
            self.ir = signal.db;
        }

        let Some(inst) = Instruction::decode(signal.rs, signal.rw, self.ir) else {
            tracing::warn!("unknown instruction: {:#010b}", self.ir);
            return;
        };

        tracing::info!("{inst:?}\n");

        self.exec(inst);
    }
}

impl Hd44780 {
    pub fn new() -> Self {
        Self {
            ir: 0,
            dr: 0,
            ac_ddram: 0,
            ac_cgram: 0,
            ddram: [0; 80],
            config: Config::new(),
            bus_state: BusState::new(),
        }
    }

    fn debug_print_ddram(&self) {
        println!("################");
        for i in 0..16 {
            if self.ac_ddram == i {
                print!("█");
            } else {
                print!("{}", CGROM[self.ddram[i as usize] as usize]);
            }
        }
        println!();
        for i in 0..16 {
            let i = 0x40 + i;
            if self.ac_ddram == i {
                print!("█");
            } else {
                print!("{}", CGROM[self.ddram[i as usize] as usize]);
            }
        }
        println!("\n################");
    }

    fn exec(&mut self, inst: Instruction) {
        match inst {
            Instruction::ClearDisplay => {
                self.ac_ddram = 0;
                self.ddram.fill(0);
            }

            Instruction::ReturnHome => {
                self.ac_ddram = 0;
                // TODO: > returns display from being shifted to original position
            }

            Instruction::EntryModeSet { id, s } => {
                self.config.increment = id;
                self.config.shift = s;
            }

            Instruction::DisplayControl { d, c, b } => {
                self.config.display_on = d;
                self.config.cursor_shown = c;
                self.config.cursor_blink = b;
            }

            Instruction::Shift { sc, rl } => {
                self.config.cursor_follows_shift = sc;
                self.config.shift_to_right = rl;
            }

            Instruction::FunctionSet { dl, n, f } => {
                self.config._8bit_mode = dl;
                self.config._2lines_display = n;
                self.config.font_5x10 = f;
            }

            Instruction::CgRamAddressSet { addr } => {
                self.ac_cgram = addr;
                self.bus_state.prev_addr_set_was_ddram = false;
            }

            Instruction::DdRamAddressSet { addr } => {
                self.ac_ddram = addr;
                self.bus_state.prev_addr_set_was_ddram = true;
            }

            Instruction::Write { data } => {
                if !self.bus_state.prev_addr_set_was_ddram {
                    unimplemented!("custom characters are not implemented")
                }

                self.ddram[self.ac_ddram as usize] = data;

                if self.config.increment {
                    self.ac_ddram += 1;
                } else {
                    self.ac_ddram -= 1;
                }

                self.debug_print_ddram();
            }
        }
    }
}

impl Default for Hd44780 {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug)]
struct BusState {
    prev_e: bool,

    /// used only in 4-bit mode
    received_4bit_half: bool,

    prev_addr_set_was_ddram: bool,
}

impl BusState {
    fn new() -> Self {
        Self {
            prev_e: false,
            received_4bit_half: false,
            prev_addr_set_was_ddram: true,
        }
    }
}

impl Default for BusState {
    fn default() -> Self {
        Self::new()
    }
}

enum Instruction {
    ClearDisplay,
    ReturnHome,
    EntryModeSet { id: bool, s: bool },
    DisplayControl { d: bool, c: bool, b: bool },
    Shift { sc: bool, rl: bool },
    FunctionSet { dl: bool, n: bool, f: bool },
    CgRamAddressSet { addr: u8 },
    DdRamAddressSet { addr: u8 },
    Write { data: u8 },
}

impl Debug for Instruction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClearDisplay => write!(f, "ClearDisplay"),
            Self::ReturnHome => write!(f, "ReturnHome"),
            Self::EntryModeSet { id, s } => f
                .debug_struct("EntryModeSet")
                .field("increment", id)
                .field("shift", s)
                .finish(),
            Self::DisplayControl { d, c, b } => f
                .debug_struct("DisplayControl")
                .field("display_on", d)
                .field("cursor_shown", c)
                .field("cursor_blink", b)
                .finish(),
            Self::Shift { sc, rl } => f
                .debug_struct("Shift")
                .field("cursor_follows_shift", sc)
                .field("shift_to_right", rl)
                .finish(),
            Self::FunctionSet { dl, n, f: ff } => f
                .debug_struct("FunctionSet")
                .field("8bit_mode", dl)
                .field("2lines_display", n)
                .field("font_5x10", ff)
                .finish(),
            Self::CgRamAddressSet { addr } => f
                .debug_struct("CgRamAddressSet")
                .field("addr", addr)
                .finish(),
            Self::DdRamAddressSet { addr } => f
                .debug_struct("DdRamAddressSet")
                .field("addr", addr)
                .finish(),
            Self::Write { data } => write!(
                f,
                "Write {{ data: {:#010b}({}) }}",
                data, CGROM[*data as usize]
            ),
        }
    }
}

impl Instruction {
    fn decode(rs: bool, rw: bool, x: u8) -> Option<Self> {
        if !rs && !rw {
            stk_macro::bitmaskeq! {
                match x {
                    0b0000_0001 => return Some(Self::ClearDisplay),
                    m_0000_001x => return Some(Self::ReturnHome),
                    m_0000_01is => return Some(Self::EntryModeSet {
                        id: i != 0,
                        s: s != 0,
                    }),
                    m_0000_1dcb => return Some(Self::DisplayControl {
                        d: d != 0,
                        c: c != 0,
                        b: b != 0,
                    }),
                    m_0001_clxx => return Some(Self::Shift {
                        sc: c != 0,
                        rl: l != 0,
                    }),
                    m_001d_nfxx => return Some(Self::FunctionSet {
                        dl: (x & 0b0001_0000) != 0,
                        n: (x & 0b0000_1000) != 0,
                        f: (x & 0b0000_0100) != 0,
                    }),
                    m_11aa_aaaa => return Some(Self::CgRamAddressSet { addr: a }),

                    // P31
                    // RS RW DB
                    // 1  0  D
                    m_1aaa_aaaa => return Some(Self::DdRamAddressSet { addr: a }),

                    _ => {},
                }
            }
        }

        // TODO: 実験ではちゃんと rw 落としてる？
        if rs && !rw {
            return Some(Self::Write { data: x });
        }

        if rs && rw {
            unimplemented!("read instruction is not implemented yet")
        }

        None
    }
}
